# 后端 + 部署初步设计方案

> 面向 **编程小白** 的渐进式指导

---

## 1. 总体思路

1. **前端已就绪**：现有 UI 能上传文件、选择顺序/随机、轮询任务状态。
2. **最小后端闭环**：
   - 接收文件 → 存硬盘
   - 排队解析 → 生成静态 HTML
   - 前端拿到 HTML → iframe 展示
3. **渐进增强**：后续再加对象存储、队列水平扩容、监控等。

> **目标**：一周内上线“可用”版本；保证代码与部署过程简单、可复制。

---

## 2. 技术栈与理由

| 层次 | 技术 | 选择理由 |
|------|------|----------|
| Web FW | **Fastify 4 + TypeScript** | 写法与 Express 类似、性能更高、丰富插件 |
| ORM   | **Prisma** | CLI 友好、生成 TS 类型、迁移简单 |
| DB    | **SQLite ➜ PostgreSQL** | 开发阶段零配置；生产时 `DATABASE_URL` 切换 PG 即可 |
| Queue | **BullMQ** | 轻量、高度封装、Redis 一键装好 |
| AI    | **Google Gemini 2.5 Pro REST** | 官方 SDK 简单；Key 保存在 `.env` |
| Parser| **mammoth / xlsx / pdf-parse / csv-parse** | 社区成熟库 |
| Auth  | **JWT + bcrypt** | 前端已有登录表单可对接 |
| File  | 本地 `uploads/` 目录 (MVP) | 避免早期引入 MinIO；后期可挂载 S3 |
| Deployment | **Docker Compose** | 单机一键起；后期可迁移到 K8s/Swarm

---

## 3. 路由设计

| 方法 | 路径 | 说明 |
|------|------|------|
| POST | `/api/auth/register` | 注册，返回 JWT |
| POST | `/api/auth/login` | 登录，返回 JWT |
| POST | `/api/upload` | 上传题库文件，返回 `quizId` + `jobId` |
| GET  | `/api/quiz/:id` | 返回 quiz 元信息及 HTML （完成后）|
| GET  | `/api/job/:id` | 返回 job 状态 `queued/active/failed/completed` |
| GET  | `/health` | 探活 |

---

## 4. 文件与目录

```
backend/
 ├─ prisma/
 │   └─ schema.prisma           # 定义 User / Quiz / Job
 ├─ src/
 │   ├─ index.ts                # Fastify 启动
 │   ├─ plugins/
 │   │   ├─ auth.ts            # JWT 解析钩子
 │   │   └─ prisma.ts          # Prisma client 注入
 │   ├─ routes/
 │   │   ├─ auth.ts
 │   │   ├─ upload.ts
 │   │   ├─ quiz.ts
 │   │   └─ job.ts
 │   ├─ workers/
 │   │   └─ quizWorker.ts      # BullMQ Worker
 │   ├─ services/
 │   │   ├─ gemini.ts          # 调用 Gemini API
 │   │   └─ parser.ts          # Word/Excel/PDF → JSON
 │   └─ utils/                 # 通用辅助函数
 ├─ Dockerfile
 └─ package.json
```

---

## 5. 核心代码片段（精简版）

### 5.1 上传路由 `upload.ts`
```ts
fastify.post('/upload', { preHandler: [fastify.jwtVerify] }, async (req, reply) => {
  const data = await req.file();                       // fastify-multipart
  const id   = crypto.randomUUID();
  const path = `uploads/${id}-${data.filename}`;
  await pump(data.file, fs.createWriteStream(path));

  // 数据库记录
  const quiz = await prisma.quiz.create({
    data: { id, title: data.filename, orderMode: req.body.order, status: 'pending', userId: req.user.id }
  });

  // 加队列
  await quizQueue.add('parse', { quizId: id, filePath: path });

  return { quizId: id, jobId: quiz.id };
});
```

### 5.2 Worker 主要逻辑 `quizWorker.ts`
```ts
queue.process('parse', async job => {
  const { quizId, filePath } = job.data;
  try {
    const qJson = await parseToJSON(filePath);              // 第 1 步：结构化

    const html  = await askGemini(qJson, job.data.order);   // 第 2 步：调用 Gemini

    await prisma.quiz.update({ where: { id: quizId }, data: { html, status: 'done' } });
  } catch (e) {
    await prisma.quiz.update({ where: { id: quizId }, data: { status: 'error', errorMsg: e.message } });
    throw e;
  }
});
```

---

## 6. Docker & Compose

### 6.1 backend/Dockerfile
```dockerfile
# --- build stage ---
FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build               # prisma generate && tsc

# --- runtime stage ---
FROM node:18-alpine
WORKDIR /app
ENV NODE_ENV=production
COPY --from=build /app/dist ./dist
COPY --from=build /app/node_modules ./node_modules
CMD ["node","dist/index.js"]
```

### 6.2 docker-compose.yml 关键片段
```yaml
services:
  backend:
    build: ./backend
    env_file: .env
    volumes: ["./backend/uploads:/app/uploads"]
    depends_on: [db, redis]
    ports: ["3001:3001"]

  worker:
    build: ./backend
    command: ["npm","run","worker"]
    env_file: .env
    volumes: ["./backend/uploads:/app/uploads"]
    depends_on: [db, redis]

  db:
    image: postgres:16-alpine   # 开发阶段可换 sqlite:file
    environment:
      POSTGRES_DB: quiz
      POSTGRES_USER: quiz
      POSTGRES_PASSWORD: quiz
    volumes: ["pgdata:/var/lib/postgresql/data"]

  redis:
    image: redis:7-alpine
volumes:
  pgdata:
```

---

## 7. 开发到上线路线图

| 阶段 | 里程碑 | 预计时长 | 关键产物 |
|------|--------|----------|----------|
| 1 | ✅ **MVP**：本地 SQLite + 同步解析（无队列） | 1 天 | 能上传 TXT，得到静态 HTML |
| 2 | ⛳ **Gemini 接入**：真 API 调用 & 错误处理 | 1 天 | 花费 Token 受控；返回长 HTML |
| 3 | 🔄 **BullMQ + Redis**：异步解析 | 0.5 天 | 前端可轮询状态 |
| 4 | 🚢 **Docker Compose**：一键部署 | 0.5 天 | `docker-compose up -d` 直达 |
| 5 | 🛡 **Auth & 限流**：JWT + fastify-rate-limit | 1 天 | 基本安全策略 |
| 6 | 📦 **格式多样化**：Word/Excel/PDF parser | 2 天 | 覆盖 90% 常见题库 |

---

## 8. 风险 & 对策
| 风险 | 级别 | 对策 |
|------|------|------|
| Gemini 响应过大 > 1 MB | 中 | 分页生成 HTML，每 50 题拼接 |
| 同时上传大量文件 | 中 | BullMQ concurrency 限制 + Pod scale |
| Word/PDF 格式边缘 Case | 高 | 提供“解析失败回显原文”兜底；用户自行排版 |
| 前端频繁轮询浪费资源 | 低 | 可以改用 WS + Redis pub/sub |

---

## 9. 小白上手建议

1. **先跑通本地版**：`npm i && npm run dev`，确保上传 TXT → 返回硬编码 HTML 成功。
2. **逐行阅读上文代码片段**，理解“上传 → 入库 → Worker → 更新状态”链条。
3. **优先掌握**：
   - Fastify 路由定义 & 钩子
   - Prisma 模型与迁移 `npx prisma migrate dev`
   - BullMQ 基本 API `add / process`
4. **调试技巧**：
   - VSCode `launch.json` attach Node
   - 在 Worker 内 `console.log` 分段日志，查解析/AI 结果
5. **学会用 Postman**：先别在意前端，手动调用 `/upload` `/job/:id` 确保链路通。

---

> **结语**：以上方案力求“先易后难、可连续迭代”。当你能让本地 TXT 上传 ➜ Gemini 返回 HTML 正常展示时，90% 的难度已被攻克。剩余只是工程化和稳固性工作，完全可在 Docker Compose 单机环境中练习并运行。祝开发顺利！
